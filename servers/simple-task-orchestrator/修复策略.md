# 任务编排MCP服务器修复策略

## 问题识别与修复方案

### 1. 编译错误修复

#### 1.1 tower-http 功能配置错误

**问题描述**: 
```rust
// main.rs:4
use tower_http::{trace::TraceLayer, cors::CorsLayer, compression::CompressionLayer, timeout::TimeoutLayer};
```

**问题分析**: 
- tower-http 需要启用特定的 features 才能使用某些模块
- 当前 Cargo.toml 中缺少必要的 feature 配置

**修复方案**:

1. **更新 Cargo.toml 依赖配置**:
```toml
[dependencies]
tower-http = { workspace = true, features = ["trace", "cors", "compression", "timeout"] }
```

2. **简化 main.rs 导入**:
```rust
// 原代码 - 需要修复
use tower_http::{trace::TraceLayer, cors::CorsLayer, compression::CompressionLayer, timeout::TimeoutLayer};

// 修复后的代码
use tower_http::trace::TraceLayer;
use tower_http::cors::CorsLayer;
use tower_http::compression::CompressionLayer;
use tower_http::timeout::TimeoutLayer;
```

#### 1.2 tracing-subscriber API 使用错误

**问题描述**: 
```rust
// main.rs:132-158
fn init_logging(config: &crate::config::LoggingConfig) {
    use tracing_subscriber::{fmt, EnvFilter, prelude::*};
    
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new(&config.level));
    
    let fmt_layer = fmt::layer()
        .with_target(false)
        .with_thread_ids(true)
        .with_thread_names(true);
    
    // ... 其他代码
}
```

**问题分析**: 
- tracing-subscriber 0.3.x 版本 API 有变化
- `prelude::*` 导入可能不完整

**修复方案**:

1. **更新 Cargo.toml**:
```toml
[dependencies]
tracing-subscriber = { workspace = true, features = ["env-filter", "json", "fmt"] }
```

2. **修复 init_logging 函数**:
```rust
fn init_logging(config: &crate::config::LoggingConfig) {
    use tracing_subscriber::{fmt, EnvFilter, util::SubscriberInitExt};
    
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new(&config.level));
    
    let fmt_layer = fmt::layer()
        .with_target(false)
        .with_thread_ids(true)
        .with_thread_names(true);
    
    tracing_subscriber::registry()
        .with(filter)
        .with(fmt_layer)
        .init();
    
    match config.format {
        crate::config::LogFormat::Json => {
            tracing_subscriber::registry()
                .with(filter)
                .with(fmt_layer.json())
                .init();
        }
        crate::config::LogFormat::Pretty => {
            tracing_subscriber::registry()
                .with(filter)
                .with(fmt_layer.pretty())
                .init();
        }
    }
}
```

#### 1.3 依赖导入问题

**问题描述**: 
- 某些模块导入路径可能不正确
- workspace 依赖可能未正确配置

**修复方案**:

1. **检查 workspace 配置**:
```toml
# 根目录 Cargo.toml
[workspace]
members = ["servers/*"]

[workspace.dependencies]
# ... 确保所有依赖都在这里定义
```

2. **修复导入路径**:
```rust
// 确保所有导入都正确
use crate::config::ConfigManager;
use crate::infrastructure::{InMemoryTaskRepository, SimpleLockManager};
use crate::services::{TaskService, TaskScheduler, TaskMonitor};
use crate::handlers::{create_routes, ApiState};
use crate::utils::RateLimiter;
```

### 2. 测试覆盖率提升

#### 2.1 测试框架搭建

**创建测试配置文件**:
```rust
// tests/common.rs
pub mod common {
    use std::sync::Arc;
    use simple_task_orchestrator::{
        infrastructure::InMemoryTaskRepository,
        services::TaskService,
        config::ConfigManager,
    };
    
    pub fn setup_test_service() -> Arc<TaskService> {
        let task_repository = Arc::new(InMemoryTaskRepository::new());
        let lock_manager = Arc::new(SimpleLockManager::new());
        Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600))
    }
    
    pub fn create_test_task() -> CreateTaskRequest {
        CreateTaskRequest {
            work_directory: "/test".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::Medium),
            tags: Some(vec!["test".to_string()]),
        }
    }
}
```

#### 2.2 核心业务逻辑测试

**TaskService 测试**:
```rust
// tests/task_service_test.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::services::TaskService;
    use simple_task_orchestrator::domain::{CreateTaskRequest, TaskPriority};
    
    #[tokio::test]
    async fn test_create_task_success() {
        let service = setup_test_service();
        let request = CreateTaskRequest {
            work_directory: "/test".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::High),
            tags: Some(vec!["test".to_string()]),
        };
        
        let result = service.create_task(request).await;
        assert!(result.is_ok());
        
        let task = result.unwrap();
        assert_eq!(task.work_directory, "/test");
        assert_eq!(task.priority, TaskPriority::High);
        assert!(!task.tags.is_empty());
    }
    
    #[tokio::test]
    async fn test_create_task_invalid_path() {
        let service = setup_test_service();
        let request = CreateTaskRequest {
            work_directory: "invalid_path".to_string(), // 不是绝对路径
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::Medium),
            tags: None,
        };
        
        let result = service.create_task(request).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("absolute path"));
    }
    
    #[tokio::test]
    async fn test_acquire_task() {
        let service = setup_test_service();
        
        // 创建任务
        let create_request = CreateTaskRequest {
            work_directory: "/test".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::High),
            tags: None,
        };
        let task = service.create_task(create_request).await.unwrap();
        
        // 获取任务
        let acquire_request = AcquireTaskRequest {
            work_path: "/test".to_string(),
            worker_id: "worker1".to_string(),
        };
        
        let result = service.acquire_task(acquire_request).await;
        assert!(result.is_ok());
        let acquired_task = result.unwrap().unwrap();
        assert_eq!(acquired_task.id, task.id);
        assert_eq!(acquired_task.status, TaskStatus::Working);
    }
}
```

#### 2.3 API 集成测试

**HTTP 客户端测试**:
```rust
// tests/api_integration_test.rs
mod tests {
    use axum_test::TestServer;
    use simple_task_orchestrator::handlers::create_routes;
    use simple_task_orchestrator::handlers::ApiState;
    use simple_task_orchestrator::services::TaskService;
    use simple_task_orchestrator::infrastructure::{InMemoryTaskRepository, SimpleLockManager};
    
    #[tokio::test]
    async fn test_create_task_api() {
        let task_repository = Arc::new(InMemoryTaskRepository::new());
        let lock_manager = Arc::new(SimpleLockManager::new());
        let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
        
        let app = create_routes().with_state(ApiState { task_service });
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt",
                "priority": "medium",
                "tags": ["test"]
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert!(json["data"].is_object());
    }
    
    #[tokio::test]
    async fn test_get_task_api() {
        let task_repository = Arc::new(InMemoryTaskRepository::new());
        let lock_manager = Arc::new(SimpleLockManager::new());
        let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
        
        let app = create_routes().with_state(ApiState { task_service });
        let server = TestServer::new(app).unwrap();
        
        // 先创建任务
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 获取任务
        let response = server.get(&format!("/api/v1/tasks/{}", task_id))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert_eq!(json["data"]["id"], task_id);
    }
}
```

#### 2.4 并发安全测试

**并发测试**:
```rust
// tests/concurrency_test.rs
mod tests {
    use super::*;
    use tokio::task::JoinSet;
    
    #[tokio::test]
    async fn test_concurrent_task_creation() {
        let service = setup_test_service();
        let mut join_set = JoinSet::new();
        
        // 并发创建100个任务
        for i in 0..100 {
            let service_clone = service.clone();
            join_set.spawn(async move {
                let request = CreateTaskRequest {
                    work_directory: format!("/test_{}", i),
                    prompt: format!("Test prompt {}", i),
                    priority: Some(TaskPriority::Medium),
                    tags: None,
                };
                service_clone.create_task(request).await
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // 验证所有任务都创建成功
        assert_eq!(results.len(), 100);
        for result in results {
            assert!(result.is_ok());
        }
    }
    
    #[tokio::test]
    async fn test_concurrent_task_acquisition() {
        let service = setup_test_service();
        
        // 创建一个任务
        let create_request = CreateTaskRequest {
            work_directory: "/test".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::High),
            tags: None,
        };
        let task = service.create_task(create_request).await.unwrap();
        
        let mut join_set = JoinSet::new();
        
        // 并发尝试获取同一个任务
        for i in 0..10 {
            let service_clone = service.clone();
            join_set.spawn(async move {
                let acquire_request = AcquireTaskRequest {
                    work_path: "/test".to_string(),
                    worker_id: format!("worker_{}", i),
                };
                service_clone.acquire_task(acquire_request).await
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // 只有一个worker应该能获取到任务
        let success_count = results.iter().filter(|r| r.as_ref().unwrap().is_some()).count();
        assert_eq!(success_count, 1);
    }
}
```

### 3. 安全机制增强

#### 3.1 API 密钥验证

**创建认证中间件**:
```rust
// src/middleware/auth.rs
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use std::sync::Arc;

pub struct AuthMiddleware {
    api_keys: Arc<Vec<String>>,
}

impl AuthMiddleware {
    pub fn new(api_keys: Vec<String>) -> Self {
        Self {
            api_keys: Arc::new(api_keys),
        }
    }
    
    pub async fn auth<B>(&self, mut request: Request<B>, next: Next<B>) -> Response {
        // 从请求头获取 API 密钥
        let api_key = request.headers()
            .get("X-API-Key")
            .and_then(|value| value.to_str().ok())
            .map(|s| s.to_string());
        
        match api_key {
            Some(key) if self.api_keys.contains(&key) => {
                // 验证通过，继续处理请求
                next.run(request).await
            }
            _ => {
                // 验证失败，返回401
                Response::builder()
                    .status(StatusCode::UNAUTHORIZED)
                    .header("content-type", "application/json")
                    .body(r#"{"success": false, "error": {"code": "UNAUTHORIZED", "message": "Invalid or missing API key"}}"#.into())
                    .unwrap()
            }
        }
    }
}
```

**更新路由配置**:
```rust
// src/handlers/mod.rs
pub fn create_routes() -> Router<ApiState> {
    Router::new()
        .route("/api/v1/tasks", post(create_task))
        .route("/api/v1/tasks", get(list_tasks))
        // ... 其他路由
        .route_layer(middleware::from_fn_with_state(
            api_state.clone(),
            auth_middleware
        ))
}
```

#### 3.2 输入验证加强

**增强验证器**:
```rust
// src/utils/validation.rs
use regex::Regex;
use std::path::Path;

pub struct Validator;

impl Validator {
    pub fn validate_work_directory(path: &str) -> Result<(), String> {
        // 检查是否为绝对路径
        if !path.starts_with('/') {
            return Err("Work directory must be an absolute path".to_string());
        }
        
        // 检查路径长度
        if path.len() > 1000 {
            return Err("Work directory path too long (max 1000 characters)".to_string());
        }
        
        // 检查路径遍历攻击
        if path.contains("..") || path.contains("~") {
            return Err("Work directory contains invalid characters".to_string());
        }
        
        // 检查路径格式
        let path_regex = Regex::new(r"^/[a-zA-Z0-9_\-/]+$").unwrap();
        if !path_regex.is_match(path) {
            return Err("Work directory contains invalid characters".to_string());
        }
        
        Ok(())
    }
    
    pub fn validate_prompt(prompt: &str) -> Result<(), String> {
        if prompt.len() < 1 || prompt.len() > 10000 {
            return Err("Prompt must be between 1 and 10000 characters".to_string());
        }
        
        // 检查潜在的注入攻击
        if prompt.contains("DROP TABLE") || prompt.contains("DELETE FROM") {
            return Err("Prompt contains potentially dangerous content".to_string());
        }
        
        Ok(())
    }
    
    pub fn validate_worker_id(worker_id: &str) -> Result<(), String> {
        if worker_id.len() < 1 || worker_id.len() > 100 {
            return Err("Worker ID must be between 1 and 100 characters".to_string());
        }
        
        // 检查字符格式
        let id_regex = Regex::new(r"^[a-zA-Z0-9_\-]+$").unwrap();
        if !id_regex.is_match(worker_id) {
            return Err("Worker ID contains invalid characters".to_string());
        }
        
        Ok(())
    }
}
```

**更新服务层验证**:
```rust
// src/services/mod.rs
use crate::utils::Validator;

pub async fn create_task(&self, request: CreateTaskRequest) -> Result<Task, String> {
    // 使用新的验证器
    Validator::validate_work_directory(&request.work_directory)?;
    Validator::validate_prompt(&request.prompt)?;
    
    // 验证标签
    if let Some(tags) = &request.tags {
        for tag in tags {
            if tag.len() > 50 {
                return Err("Tags must be between 1 and 50 characters".to_string());
            }
        }
    }
    
    // ... 原有逻辑
}
```

#### 3.3 审计日志

**创建审计日志系统**:
```rust
// src/utils/audit.rs
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLog {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub user_id: Option<String>,
    pub action: String,
    pub resource: String,
    pub details: serde_json::Value,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
}

pub struct AuditLogger {
    logs: Arc<RwLock<Vec<AuditLog>>>,
}

impl AuditLogger {
    pub fn new() -> Self {
        Self {
            logs: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    pub async fn log(&self, action: String, resource: String, details: serde_json::Value) {
        let log = AuditLog {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: Utc::now(),
            user_id: None, // 可以从认证上下文获取
            action,
            resource,
            details,
            ip_address: None, // 可以从请求中获取
            user_agent: None, // 可以从请求中获取
        };
        
        let mut logs = self.logs.write().await;
        logs.push(log);
        
        // 保持日志数量在合理范围内
        if logs.len() > 10000 {
            logs.drain(0..logs.len() - 10000);
        }
    }
    
    pub async fn get_logs(&self, limit: Option<usize>) -> Vec<AuditLog> {
        let logs = self.logs.read().await;
        let limit = limit.unwrap_or(100);
        logs.iter().rev().take(limit).cloned().collect()
    }
}
```

### 4. 性能优化

#### 4.1 锁机制优化

**实现读写锁分离**:
```rust
// src/infrastructure/optimized_lock_manager.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use chrono::{DateTime, Utc};
use async_trait::async_trait;

pub struct OptimizedLockManager {
    read_locks: Arc<RwLock<HashMap<String, Vec<String>>>>, // 资源ID -> 读取者列表
    write_locks: Arc<RwLock<HashMap<String, (String, DateTime<Utc>)>>>, // 资源ID -> (写入者, 过期时间)
    lock_queue: Arc<Mutex<HashMap<String, Vec<String>>>>, // 等待队列
}

impl OptimizedLockManager {
    pub fn new() -> Self {
        Self {
            read_locks: Arc::new(RwLock::new(HashMap::new())),
            write_locks: Arc::new(RwLock::new(HashMap::new())),
            lock_queue: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

#[async_trait]
impl LockManager for OptimizedLockManager {
    async fn try_acquire(&self, resource_id: &str, owner_id: &str, ttl_seconds: u64) -> Result<bool, String> {
        // 清理过期锁
        self.cleanup_expired_locks().await;
        
        let expires_at = Utc::now() + chrono::Duration::seconds(ttl_seconds as i64);
        
        // 尝试获取写锁
        let mut write_locks = self.write_locks.write().await;
        if let Some((current_owner, _)) = write_locks.get(resource_id) {
            if current_owner == owner_id {
                // 已经是锁的所有者，更新过期时间
                write_locks.insert(resource_id.to_string(), (owner_id.to_string(), expires_at));
                return Ok(true);
            }
            return Ok(false);
        }
        
        // 检查是否有读锁
        let read_locks = self.read_locks.read().await;
        if let Some(readers) = read_locks.get(resource_id) {
            if !readers.is_empty() {
                return Ok(false);
            }
        }
        
        // 获取写锁
        write_locks.insert(resource_id.to_string(), (owner_id.to_string(), expires_at));
        Ok(true)
    }
    
    async fn release(&self, resource_id: &str, owner_id: &str) -> Result<bool, String> {
        let mut write_locks = self.write_locks.write().await;
        
        if let Some((current_owner, _)) = write_locks.get(resource_id) {
            if current_owner == owner_id {
                write_locks.remove(resource_id);
                return Ok(true);
            }
        }
        
        Ok(false)
    }
    
    async fn check_lock(&self, resource_id: &str) -> Result<Option<String>, String> {
        let write_locks = self.write_locks.read().await;
        Ok(write_locks.get(resource_id).map(|(owner, _)| owner.clone()))
    }
    
    async fn cleanup_expired_locks(&self) -> Result<u64, String> {
        let mut write_locks = self.write_locks.write().await;
        let now = Utc::now();
        let initial_count = write_locks.len();
        
        write_locks.retain(|_, (_, expires_at)| *expires_at > now);
        
        Ok((initial_count - write_locks.len()) as u64)
    }
}
```

#### 4.2 缓存实现

**任务结果缓存**:
```rust
// src/infrastructure/cache.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc};
use crate::domain::TaskResult;

#[derive(Clone)]
pub struct TaskResultCache {
    cache: Arc<RwLock<HashMap<String, (TaskResult, DateTime<Utc>)>>>,
    ttl_seconds: u64,
}

impl TaskResultCache {
    pub fn new(ttl_seconds: u64) -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
            ttl_seconds,
        }
    }
    
    pub async fn get(&self, key: &str) -> Option<TaskResult> {
        let cache = self.cache.read().await;
        
        if let Some((result, expires_at)) = cache.get(key) {
            if *expires_at > Utc::now() {
                return Some(result.clone());
            }
        }
        
        None
    }
    
    pub async fn put(&self, key: &str, result: TaskResult) {
        let mut cache = self.cache.write().await;
        let expires_at = Utc::now() + chrono::Duration::seconds(self.ttl_seconds as i64);
        
        cache.insert(key.to_string(), (result, expires_at));
        
        // 清理过期缓存
        if cache.len() > 1000 {
            cache.retain(|_, (_, expires_at)| *expires_at > Utc::now());
        }
    }
    
    pub async fn remove(&self, key: &str) {
        let mut cache = self.cache.write().await;
        cache.remove(key);
    }
    
    pub async fn clear(&self) {
        let mut cache = self.cache.write().await;
        cache.clear();
    }
}
```

## 修复优先级

### 高优先级 (立即修复)
1. **编译错误** - 阻止项目构建
2. **基础测试框架** - 确保代码质量
3. **API 密钥验证** - 安全基本要求

### 中优先级 (本周内完成)
1. **输入验证** - 防止安全漏洞
2. **核心业务逻辑测试** - 确保功能正确性
3. **性能优化** - 提升系统性能

### 低优先级 (下周完成)
1. **审计日志** - 增强可观测性
2. **文档完善** - 提升用户体验
3. **高级测试** - 进一步保证质量

## 验证步骤

### 编译验证
```bash
# 1. 检查编译
cargo build

# 2. 运行测试
cargo test

# 3. 格式检查
cargo fmt --all -- --check

# 4. 静态分析
cargo clippy --all-targets --all-features -- -D warnings
```

### 功能验证
```bash
# 1. 启动服务
cargo run

# 2. 测试 API
curl -X POST http://localhost:8080/api/v1/tasks \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your-api-key" \
  -d '{"work_directory": "/test", "prompt": "Test prompt"}'

# 3. 检查健康状态
curl http://localhost:8080/health
```

### 性能验证
```bash
# 1. 性能测试
cargo bench

# 2. 负载测试 (使用 k6)
k6 run test/load_test.js
```

---

**制定日期**: 2025-08-18  
**技术负责人**: 待指定  
**预计修复时间**: 3-5天