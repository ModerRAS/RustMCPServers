# 任务编排MCP服务器测试增强计划

## 测试现状分析

### 当前测试状态
- **测试覆盖率**: ~10%
- **测试文件数量**: 0 (无独立测试文件)
- **测试类型**: 仅有少量内嵌单元测试
- **测试框架**: 基本cargo test配置
- **测试数据**: 无测试数据管理

### 测试缺口分析
1. **单元测试缺失**: 70%的核心逻辑未被测试
2. **集成测试缺失**: API端点完全未测试
3. **异常测试缺失**: 错误处理未验证
4. **性能测试缺失**: 无基准测试
5. **并发测试缺失**: 线程安全性未验证
6. **安全测试缺失**: 安全机制未测试

## 测试目标

### 量化目标
- **总体测试覆盖率**: 从10%提升至70%
- **单元测试覆盖率**: 达到85%
- **集成测试覆盖率**: 达到90%
- **API测试覆盖率**: 达到100%
- **异常测试覆盖率**: 达到80%

### 质量目标
- **代码质量**: 通过所有静态分析
- **功能正确性**: 所有关键功能被验证
- **性能指标**: 满足性能要求
- **安全性**: 无已知安全漏洞

## 测试架构设计

### 测试目录结构
```
tests/
├── common/                 # 通用测试工具
│   ├── mod.rs
│   ├── test_setup.rs       # 测试环境设置
│   ├── test_data.rs        # 测试数据生成器
│   └── test_utils.rs       # 测试工具函数
├── unit/                   # 单元测试
│   ├── mod.rs
│   ├── domain_tests.rs     # 领域模型测试
│   ├── service_tests.rs    # 服务层测试
│   ├── repository_tests.rs # 仓库层测试
│   └── utils_tests.rs     # 工具类测试
├── integration/            # 集成测试
│   ├── mod.rs
│   ├── api_tests.rs        # API端点测试
│   ├── workflow_tests.rs   # 工作流测试
│   └── database_tests.rs   # 数据库测试
├── performance/            # 性能测试
│   ├── mod.rs
│   ├── benchmark_tests.rs  # 基准测试
│   └── load_tests.rs       # 负载测试
├── security/               # 安全测试
│   ├── mod.rs
│   ├── auth_tests.rs       # 认证测试
│   ├── validation_tests.rs # 验证测试
│   └── injection_tests.rs  # 注入攻击测试
└── e2e/                    # 端到端测试
    ├── mod.rs
    └── scenario_tests.rs   # 场景测试
```

### 测试依赖配置

**更新 Cargo.toml**:
```toml
[dev-dependencies]
# 原有依赖
tokio-test = { workspace = true }
mockall = "0.11"
tower = { workspace = true }

# 新增测试依赖
axum-test = "0.1"          # HTTP测试
reqwest = { version = "0.11", features = ["json"] }  # HTTP客户端
serde_json = "1.0"         # JSON处理
fake = { version = "2.9", features = ["derive"] }    # 假数据生成
rand = "0.8"               # 随机数生成
criterion = { version = "0.5", features = ["html_reports"] }  # 基准测试
tokio = { version = "1.0", features = ["full"] }     # 异步测试
tracing-test = "0.2"       # 日志测试
mockito = "1.4"            # HTTP模拟
tempfile = "3.8"           # 临时文件
testcontainers = "0.15"    # 容器测试

# 测试工具
assert_cmd = "2.0"         # 命令行测试
predicates = "3.0"         # 断言库
pretty_assertions = "1.4"  # 美化断言
insta = "1.34"             # 快照测试
```

## 测试实现计划

### 第一阶段: 测试基础设施 (1天)

#### 1.1 通用测试工具
```rust
// tests/common/mod.rs
pub mod test_setup;
pub mod test_data;
pub mod test_utils;

pub use test_setup::*;
pub use test_data::*;
pub use test_utils::*;
```

```rust
// tests/common/test_setup.rs
use std::sync::Arc;
use simple_task_orchestrator::{
    infrastructure::InMemoryTaskRepository,
    services::TaskService,
    config::ConfigManager,
};

pub struct TestEnvironment {
    pub task_service: Arc<TaskService>,
    pub config_manager: ConfigManager,
}

impl TestEnvironment {
    pub fn new() -> Self {
        let task_repository = Arc::new(InMemoryTaskRepository::new());
        let lock_manager = Arc::new(SimpleLockManager::new());
        let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
        let config_manager = ConfigManager::new().unwrap();
        
        Self {
            task_service,
            config_manager,
        }
    }
    
    pub async fn setup_test_tasks(&self, count: usize) -> Vec<Task> {
        let mut tasks = Vec::new();
        
        for i in 0..count {
            let request = CreateTaskRequest {
                work_directory: format!("/test_{}", i),
                prompt: format!("Test prompt {}", i),
                priority: Some(TaskPriority::Medium),
                tags: Some(vec!["test".to_string()]),
            };
            
            let task = self.task_service.create_task(request).await.unwrap();
            tasks.push(task);
        }
        
        tasks
    }
}
```

#### 1.2 测试数据生成器
```rust
// tests/common/test_data.rs
use fake::{Fake, Faker};
use fake::faker::lorem::en::*;
use fake::faker::internet::en::*;
use simple_task_orchestrator::domain::*;

pub struct TestDataGenerator;

impl TestDataGenerator {
    pub fn create_task_request() -> CreateTaskRequest {
        CreateTaskRequest {
            work_directory: format!("/test/{}", UUIDv4.fake()),
            prompt: Sentence(1..10).fake(),
            priority: Some(TaskPriority::Medium),
            tags: Some(vec![Word().fake()]),
        }
    }
    
    pub fn create_worker_id() -> String {
        Username().fake()
    }
    
    pub fn create_task_id() -> TaskId {
        TaskId::from_uuid(uuid::Uuid::new_v4())
    }
    
    pub fn create_task_result() -> TaskResult {
        TaskResult::success(Sentence(1..5).fake())
    }
}
```

#### 1.3 测试工具函数
```rust
// tests/common/test_utils.rs
use std::time::Duration;
use tokio::time::sleep;

pub async fn wait_for_condition<F, Fut>(condition: F, timeout: Duration) -> Result<(), String>
where
    F: Fn() -> Fut,
    Fut: std::future::Future<Output = bool>,
{
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if condition().await {
            return Ok(());
        }
        sleep(Duration::from_millis(100)).await;
    }
    
    Err("Condition not met within timeout".to_string())
}

pub fn assert_task_equals(expected: &Task, actual: &Task) {
    assert_eq!(expected.id, actual.id);
    assert_eq!(expected.work_directory, actual.work_directory);
    assert_eq!(expected.prompt, actual.prompt);
    assert_eq!(expected.priority, actual.priority);
    assert_eq!(expected.status, actual.status);
}

pub fn create_test_app() -> Router<ApiState> {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    create_routes().with_state(ApiState { task_service })
}
```

### 第二阶段: 单元测试 (2天)

#### 2.1 领域模型测试
```rust
// tests/unit/domain_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::domain::*;
    
    #[test]
    fn test_task_id_creation() {
        let task_id = TaskId::new();
        assert!(!task_id.to_string().is_empty());
    }
    
    #[test]
    fn test_task_id_from_uuid() {
        let uuid = uuid::Uuid::new_v4();
        let task_id = TaskId::from_uuid(uuid);
        assert_eq!(task_id.as_uuid(), &uuid);
    }
    
    #[test]
    fn test_worker_id_validation() {
        // 有效ID
        assert!(WorkerId::new("valid_worker".to_string()).is_ok());
        
        // 空ID
        assert!(WorkerId::new("".to_string()).is_err());
        
        // 过长ID
        let long_id = "a".repeat(101);
        assert!(WorkerId::new(long_id).is_err());
    }
    
    #[test]
    fn test_task_status_transitions() {
        use TaskStatus::*;
        
        // 有效转换
        assert!(Waiting.can_transition_to(&Working));
        assert!(Working.can_transition_to(&Completed));
        assert!(Working.can_transition_to(&Failed));
        assert!(Failed.can_transition_to(&Waiting));
        
        // 无效转换
        assert!(!Completed.can_transition_to(&Working));
        assert!(!Working.can_transition_to(&Waiting));
    }
    
    #[test]
    fn test_task_lifecycle() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // 初始状态
        assert_eq!(task.status, TaskStatus::Waiting);
        assert!(task.worker_id.is_none());
        assert!(task.started_at.is_none());
        
        // 开始任务
        let worker_id = WorkerId::new("worker1".to_string()).unwrap();
        task.start(worker_id.clone()).unwrap();
        assert_eq!(task.status, TaskStatus::Working);
        assert_eq!(task.worker_id, Some(worker_id));
        assert!(task.started_at.is_some());
        
        // 完成任务
        let result = TaskResult::success("Task completed".to_string());
        task.complete(result).unwrap();
        assert_eq!(task.status, TaskStatus::Completed);
        assert!(task.completed_at.is_some());
    }
    
    #[test]
    fn test_task_retry_logic() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // 设置为失败状态
        task.fail("Test failure".to_string()).unwrap();
        assert_eq!(task.status, TaskStatus::Failed);
        assert_eq!(task.retry_count, 0);
        
        // 重试任务
        task.retry().unwrap();
        assert_eq!(task.status, TaskStatus::Waiting);
        assert_eq!(task.retry_count, 1);
        assert!(task.worker_id.is_none());
        
        // 测试重试限制
        task.max_retries = 1;
        task.fail("Another failure".to_string()).unwrap();
        assert!(task.retry().is_err());
    }
    
    #[test]
    fn test_task_timeout() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // 未开始的任务不应超时
        assert!(!task.is_expired(3600));
        
        // 开始任务
        let worker_id = WorkerId::new("worker1".to_string()).unwrap();
        task.start(worker_id).unwrap();
        
        // 刚开始的任务不应超时
        assert!(!task.is_expired(3600));
        
        // 模拟时间过期
        task.started_at = Some(task.started_at.unwrap() - chrono::Duration::seconds(3700));
        assert!(task.is_expired(3600));
    }
}
```

#### 2.2 服务层测试
```rust
// tests/unit/service_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::services::*;
    use simple_task_orchestrator::domain::*;
    
    #[tokio::test]
    async fn test_create_task_success() {
        let env = TestEnvironment::new();
        let request = TestDataGenerator::create_task_request();
        
        let result = env.task_service.create_task(request).await;
        assert!(result.is_ok());
        
        let task = result.unwrap();
        assert!(!task.id.to_string().is_empty());
        assert_eq!(task.status, TaskStatus::Waiting);
        assert_eq!(task.retry_count, 0);
    }
    
    #[tokio::test]
    async fn test_create_task_validation() {
        let env = TestEnvironment::new();
        
        // 测试无效路径
        let invalid_request = CreateTaskRequest {
            work_directory: "invalid_path".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::Medium),
            tags: None,
        };
        
        let result = env.task_service.create_task(invalid_request).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("absolute path"));
    }
    
    #[tokio::test]
    async fn test_acquire_task() {
        let env = TestEnvironment::new();
        
        // 创建测试任务
        let create_request = TestDataGenerator::create_task_request();
        let task = env.task_service.create_task(create_request).await.unwrap();
        
        // 获取任务
        let acquire_request = AcquireTaskRequest {
            work_path: task.work_directory.clone(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        
        let result = env.task_service.acquire_task(acquire_request).await;
        assert!(result.is_ok());
        
        let acquired_task = result.unwrap().unwrap();
        assert_eq!(acquired_task.id, task.id);
        assert_eq!(acquired_task.status, TaskStatus::Working);
    }
    
    #[tokio::test]
    async fn test_acquire_task_no_available() {
        let env = TestEnvironment::new();
        
        let acquire_request = AcquireTaskRequest {
            work_path: "/nonexistent".to_string(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        
        let result = env.task_service.acquire_task(acquire_request).await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }
    
    #[tokio::test]
    async fn test_complete_task() {
        let env = TestEnvironment::new();
        
        // 创建并获取任务
        let create_request = TestDataGenerator::create_task_request();
        let task = env.task_service.create_task(create_request).await.unwrap();
        
        let acquire_request = AcquireTaskRequest {
            work_path: task.work_directory.clone(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        let acquired_task = env.task_service.acquire_task(acquire_request).await.unwrap().unwrap();
        
        // 完成任务
        let complete_request = CompleteTaskRequest {
            original_prompt: None,
            result: Some(TaskDataGenerator::create_task_result()),
        };
        
        let result = env.task_service.complete_task(&acquired_task.id, complete_request).await;
        assert!(result.is_ok());
        
        let completed_task = result.unwrap();
        assert_eq!(completed_task.status, TaskStatus::Completed);
        assert!(completed_task.completed_at.is_some());
    }
    
    #[tokio::test]
    async fn test_task_statistics() {
        let env = TestEnvironment::new();
        
        // 创建测试任务
        env.setup_test_tasks(10).await;
        
        let stats = env.task_service.get_statistics().await.unwrap();
        assert_eq!(stats.total_tasks, 10);
        assert_eq!(stats.completed_tasks, 0);
        assert_eq!(stats.failed_tasks, 0);
        assert_eq!(stats.active_tasks, 10);
        assert_eq!(stats.success_rate, 0.0);
    }
}
```

#### 2.3 仓库层测试
```rust
// tests/unit/repository_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::infrastructure::*;
    
    #[tokio::test]
    async fn test_in_memory_repository_create() {
        let repo = InMemoryTaskRepository::new();
        let task = TestDataGenerator::create_task();
        
        let result = repo.create_task(&task).await;
        assert!(result.is_ok());
        
        let task_id = result.unwrap();
        assert_eq!(task_id, task.id);
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_get() {
        let repo = InMemoryTaskRepository::new();
        let task = TestDataGenerator::create_task();
        
        let task_id = repo.create_task(&task).await.unwrap();
        let retrieved_task = repo.get_task(&task_id).await.unwrap();
        
        assert!(retrieved_task.is_some());
        assert_eq!(retrieved_task.unwrap().id, task.id);
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_update() {
        let repo = InMemoryTaskRepository::new();
        let mut task = TestDataGenerator::create_task();
        
        repo.create_task(&task).await.unwrap();
        
        // 更新任务
        task.prompt = "Updated prompt".to_string();
        repo.update_task(&task).await.unwrap();
        
        let retrieved_task = repo.get_task(&task.id).await.unwrap().unwrap();
        assert_eq!(retrieved_task.prompt, "Updated prompt");
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_list() {
        let repo = InMemoryTaskRepository::new();
        
        // 创建测试任务
        for i in 0..5 {
            let mut task = TestDataGenerator::create_task();
            task.priority = if i % 2 == 0 { TaskPriority::High } else { TaskPriority::Low };
            repo.create_task(&task).await.unwrap();
        }
        
        // 测试过滤
        let filter = TaskFilter::new().with_priority(TaskPriority::High);
        let (tasks, total) = repo.list_tasks(&filter).await.unwrap();
        
        assert_eq!(total, 3); // 5个任务中3个是高优先级
        assert_eq!(tasks.len(), 3);
        for task in tasks {
            assert_eq!(task.priority, TaskPriority::High);
        }
    }
}
```

### 第三阶段: 集成测试 (2天)

#### 3.1 API端点测试
```rust
// tests/integration/api_tests.rs
mod tests {
    use super::*;
    use axum_test::TestServer;
    use simple_task_orchestrator::handlers::*;
    
    #[tokio::test]
    async fn test_create_task_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt",
                "priority": "medium",
                "tags": ["test"]
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert!(json["data"].is_object());
        assert_eq!(json["data"]["work_directory"], "/test");
    }
    
    #[tokio::test]
    async fn test_create_task_validation_error() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "invalid_path",  // 无效路径
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        assert!(json["error"]["message"].as_str().unwrap().contains("absolute path"));
    }
    
    #[tokio::test]
    async fn test_get_task_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 先创建任务
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 获取任务
        let response = server.get(&format!("/api/v1/tasks/{}", task_id))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert_eq!(json["data"]["id"], task_id);
    }
    
    #[tokio::test]
    async fn test_get_task_not_found() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.get("/api/v1/tasks/00000000-0000-0000-0000-000000000000")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        assert_eq!(json["error"]["code"], "NOT_FOUND");
    }
    
    #[tokio::test]
    async fn test_list_tasks_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 创建几个任务
        for i in 0..3 {
            server.post("/api/v1/tasks")
                .json(&serde_json::json!({
                    "work_directory": format!("/test_{}", i),
                    "prompt": format!("Test prompt {}", i)
                }))
                .await;
        }
        
        let response = server.get("/api/v1/tasks")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert!(json["data"].as_array().unwrap().len() >= 3);
    }
    
    #[tokio::test]
    async fn test_health_check() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.get("/health")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert_eq!(json["data"]["status"], "healthy");
    }
}
```

#### 3.2 工作流测试
```rust
// tests/integration/workflow_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::handlers::*;
    
    #[tokio::test]
    async fn test_complete_task_workflow() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 1. 创建任务
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(create_response.status_code(), 200);
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 2. 获取任务
        let acquire_response = server.get(&format!("/api/v1/tasks/next?work_path=/test&worker_id=worker1"))
            .await;
        
        assert_eq!(acquire_response.status_code(), 200);
        let acquire_json = acquire_response.json();
        assert!(acquire_json["success"].as_bool().unwrap());
        assert!(acquire_json["data"].is_object());
        
        // 3. 完成任务
        let complete_response = server.post(&format!("/api/v1/tasks/{}/complete", task_id))
            .json(&serde_json::json!({
                "result": {
                    "status": "success",
                    "output": "Task completed successfully"
                }
            }))
            .await;
        
        assert_eq!(complete_response.status_code(), 200);
        let complete_json = complete_response.json();
        assert!(complete_json["success"].as_bool().unwrap());
        assert_eq!(complete_json["data"]["status"], "completed");
        
        // 4. 验证任务状态
        let get_response = server.get(&format!("/api/v1/tasks/{}", task_id))
            .await;
        
        assert_eq!(get_response.status_code(), 200);
        let get_json = get_response.json();
        assert_eq!(get_json["data"]["status"], "completed");
    }
    
    #[tokio::test]
    async fn test_task_retry_workflow() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 1. 创建任务
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 2. 获取任务
        server.get(&format!("/api/v1/tasks/next?work_path=/test&worker_id=worker1"))
            .await;
        
        // 3. 模拟任务失败
        let fail_response = server.post(&format!("/api/v1/tasks/{}/complete", task_id))
            .json(&serde_json::json!({
                "result": {
                    "status": "failure",
                    "output": "Task failed"
                }
            }))
            .await;
        
        assert_eq!(fail_response.status_code(), 200);
        
        // 4. 重试任务
        let retry_response = server.post(&format!("/api/v1/tasks/{}/retry", task_id))
            .await;
        
        assert_eq!(retry_response.status_code(), 200);
        let retry_json = retry_response.json();
        assert!(retry_json["success"].as_bool().unwrap());
        assert_eq!(retry_json["data"]["status"], "waiting");
        assert_eq!(retry_json["data"]["retry_count"], 1);
    }
}
```

### 第四阶段: 并发和安全测试 (1天)

#### 4.1 并发测试
```rust
// tests/integration/concurrency_tests.rs
mod tests {
    use super::*;
    use tokio::task::JoinSet;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_concurrent_task_creation() {
        let app = create_test_app();
        let server = Arc::new(TestServer::new(app).unwrap());
        
        let mut join_set = JoinSet::new();
        
        // 并发创建100个任务
        for i in 0..100 {
            let server_clone = server.clone();
            join_set.spawn(async move {
                server_clone.post("/api/v1/tasks")
                    .json(&serde_json::json!({
                        "work_directory": format!("/test_{}", i),
                        "prompt": format!("Test prompt {}", i)
                    }))
                    .await
                    .status_code()
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // 验证所有请求都成功
        for status_code in results {
            assert_eq!(status_code, 200);
        }
    }
    
    #[tokio::test]
    async fn test_concurrent_task_acquisition() {
        let app = create_test_app();
        let server = Arc::new(TestServer::new(app).unwrap());
        
        // 创建一个任务
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        let mut join_set = JoinSet::new();
        
        // 并发尝试获取同一个任务
        for i in 0..10 {
            let server_clone = server.clone();
            join_set.spawn(async move {
                server_clone.get(&format!(
                    "/api/v1/tasks/next?work_path=/test&worker_id=worker_{}",
                    i
                ))
                .await
                .json()
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // 只有一个worker应该能获取到任务
        let success_count = results.iter()
            .filter(|json| json["success"].as_bool().unwrap() && json["data"].is_object())
            .count();
        assert_eq!(success_count, 1);
    }
}
```

#### 4.2 安全测试
```rust
// tests/security/auth_tests.rs
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_api_key_required() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        // 如果实现了API密钥验证，应该返回401
        // 目前可能返回200，需要根据实际实现调整
        assert!(response.status_code() == 200 || response.status_code() == 401);
    }
    
    #[tokio::test]
    async fn test_input_validation() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 测试路径遍历攻击
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test/../../../etc",
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        
        // 测试SQL注入
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "'; DROP TABLE tasks; --"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
    }
}
```

### 第五阶段: 性能测试 (1天)

#### 5.1 基准测试
```rust
// tests/performance/benchmark_tests.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use simple_task_orchestrator::services::TaskService;
use simple_task_orchestrator::infrastructure::{InMemoryTaskRepository, SimpleLockManager};
use std::sync::Arc;

fn bench_task_creation(c: &mut Criterion) {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    let mut group = c.benchmark_group("task_creation");
    
    for size in [1, 10, 100].iter() {
        group.bench_with_input(BenchmarkId::new("create_tasks", size), size, |b, &size| {
            b.to_async(tokio::runtime::Runtime::new().unwrap())
                .iter(|| async {
                    for _ in 0..size {
                        let request = TestDataGenerator::create_task_request();
                        task_service.create_task(request).await.unwrap();
                    }
                });
        });
    }
    
    group.finish();
}

fn bench_task_acquisition(c: &mut Criterion) {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    // 预先创建任务
    tokio::runtime::Runtime::new().unwrap().block_on(async {
        for i in 0..100 {
            let request = CreateTaskRequest {
                work_directory: "/test".to_string(),
                prompt: format!("Test prompt {}", i),
                priority: Some(TaskPriority::Medium),
                tags: None,
            };
            task_service.create_task(request).await.unwrap();
        }
    });
    
    c.bench_function("task_acquisition", |b| {
        b.to_async(tokio::runtime::Runtime::new().unwrap())
            .iter(|| async {
                let request = AcquireTaskRequest {
                    work_path: "/test".to_string(),
                    worker_id: "worker1".to_string(),
                };
                task_service.acquire_task(request).await
            });
    });
}

criterion_group!(benches, bench_task_creation, bench_task_acquisition);
criterion_main!(benches);
```

#### 5.2 负载测试
```javascript
// tests/load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
    stages: [
        { duration: '30s', target: 10 },  // 预热
        { duration: '1m', target: 50 },   // 负载
        { duration: '30s', target: 0 },   // 冷却
    ],
    thresholds: {
        http_req_duration: ['p(95)<200'], // 95%的请求在200ms内完成
        http_req_failed: ['rate<0.01'],   // 失败率小于1%
    },
};

const BASE_URL = 'http://localhost:8080';

export default function () {
    // 创建任务
    let createResponse = http.post(`${BASE_URL}/api/v1/tasks`, JSON.stringify({
        work_directory: `/test/${__VU}`,
        prompt: `Test prompt from VU ${__VU}`,
        priority: 'medium',
        tags: ['load-test'],
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
    
    check(createResponse, {
        'create task status is 200': (r) => r.status === 200,
        'create task success': (r) => JSON.parse(r.body).success === true,
    });
    
    // 获取任务列表
    let listResponse = http.get(`${BASE_URL}/api/v1/tasks`);
    
    check(listResponse, {
        'list tasks status is 200': (r) => r.status === 200,
        'list tasks success': (r) => JSON.parse(r.body).success === true,
    });
    
    sleep(1);
}
```

## 测试运行和报告

### 测试运行脚本
```bash
#!/bin/bash
# scripts/run_tests.sh

set -e

echo "🧪 运行完整测试套件..."

# 1. 单元测试
echo "📋 运行单元测试..."
cargo test --lib -- --test-threads=1

# 2. 集成测试
echo "🔗 运行集成测试..."
cargo test --test "*"

# 3. 性能测试
echo "⚡ 运行性能测试..."
cargo bench

# 4. 代码覆盖率
echo "📊 生成代码覆盖率报告..."
cargo tarpaulin --out Html --output-dir coverage/

# 5. 生成测试报告
echo "📄 生成测试报告..."
python scripts/generate_test_report.py

echo "✅ 测试完成！"
echo "📈 查看覆盖率报告: coverage/index.html"
```

### 测试报告模板
```python
# scripts/generate_test_report.py
import json
import datetime
import subprocess

def generate_test_report():
    report = {
        "timestamp": datetime.datetime.now().isoformat(),
        "project": "Simple Task Orchestrator",
        "version": "1.0.0",
        "test_results": {}
    }
    
    # 运行测试并收集结果
    try:
        # 单元测试结果
        unit_result = subprocess.run(
            ["cargo", "test", "--lib", "--", "--test-threads=1"],
            capture_output=True, text=True
        )
        report["test_results"]["unit_tests"] = {
            "passed": unit_result.returncode == 0,
            "output": unit_result.stdout,
            "errors": unit_result.stderr
        }
        
        # 集成测试结果
        integration_result = subprocess.run(
            ["cargo", "test", "--test", "*"],
            capture_output=True, text=True
        )
        report["test_results"]["integration_tests"] = {
            "passed": integration_result.returncode == 0,
            "output": integration_result.stdout,
            "errors": integration_result.stderr
        }
        
        # 性能测试结果
        benchmark_result = subprocess.run(
            ["cargo", "bench"],
            capture_output=True, text=True
        )
        report["test_results"]["benchmark_tests"] = {
            "passed": benchmark_result.returncode == 0,
            "output": benchmark_result.stdout,
            "errors": benchmark_result.stderr
        }
        
    except Exception as e:
        report["error"] = str(e)
    
    # 保存报告
    with open("test_report.json", "w") as f:
        json.dump(report, f, indent=2)
    
    print("测试报告已生成: test_report.json")

if __name__ == "__main__":
    generate_test_report()
```

## 测试质量保证

### 测试覆盖率要求
- **行覆盖率**: ≥70%
- **函数覆盖率**: ≥80%
- **分支覆盖率**: ≥60%
- **总体评分**: ≥85%

### 测试质量检查
1. **测试独立性**: 每个测试都应该独立运行
2. **测试可重复性**: 测试结果应该稳定可重复
3. **测试覆盖范围**: 覆盖所有关键业务逻辑
4. **测试性能**: 测试本身应该快速执行
5. **测试维护性**: 测试代码应该易于维护

### 持续集成配置
```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run tests
      run: |
        cargo fmt --all -- --check
        cargo clippy --all-targets --all-features -- -D warnings
        cargo test --all
        cargo tarpaulin --out Xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./cobertura.xml
```

## 测试完成标准

### 功能测试标准
- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 所有API端点被测试
- [ ] 所有异常情况被覆盖
- [ ] 所有安全机制被验证

### 性能测试标准
- [ ] API响应时间 < 100ms (95%)
- [ ] 并发处理能力 ≥ 1000 RPS
- [ ] 内存使用稳定
- [ ] 无内存泄漏

### 质量标准
- [ ] 代码覆盖率 ≥ 70%
- [ ] 静态分析通过
- [ ] 测试文档完整
- [ ] 测试报告生成

---

**制定日期**: 2025-08-18  
**预计完成时间**: 7天  
**测试负责人**: 待指定  
**技术负责人**: 待指定