# ä»»åŠ¡ç¼–æ’MCPæœåŠ¡å™¨æµ‹è¯•å¢å¼ºè®¡åˆ’

## æµ‹è¯•ç°çŠ¶åˆ†æ

### å½“å‰æµ‹è¯•çŠ¶æ€
- **æµ‹è¯•è¦†ç›–ç‡**: ~10%
- **æµ‹è¯•æ–‡ä»¶æ•°é‡**: 0 (æ— ç‹¬ç«‹æµ‹è¯•æ–‡ä»¶)
- **æµ‹è¯•ç±»å‹**: ä»…æœ‰å°‘é‡å†…åµŒå•å…ƒæµ‹è¯•
- **æµ‹è¯•æ¡†æ¶**: åŸºæœ¬cargo testé…ç½®
- **æµ‹è¯•æ•°æ®**: æ— æµ‹è¯•æ•°æ®ç®¡ç†

### æµ‹è¯•ç¼ºå£åˆ†æ
1. **å•å…ƒæµ‹è¯•ç¼ºå¤±**: 70%çš„æ ¸å¿ƒé€»è¾‘æœªè¢«æµ‹è¯•
2. **é›†æˆæµ‹è¯•ç¼ºå¤±**: APIç«¯ç‚¹å®Œå…¨æœªæµ‹è¯•
3. **å¼‚å¸¸æµ‹è¯•ç¼ºå¤±**: é”™è¯¯å¤„ç†æœªéªŒè¯
4. **æ€§èƒ½æµ‹è¯•ç¼ºå¤±**: æ— åŸºå‡†æµ‹è¯•
5. **å¹¶å‘æµ‹è¯•ç¼ºå¤±**: çº¿ç¨‹å®‰å…¨æ€§æœªéªŒè¯
6. **å®‰å…¨æµ‹è¯•ç¼ºå¤±**: å®‰å…¨æœºåˆ¶æœªæµ‹è¯•

## æµ‹è¯•ç›®æ ‡

### é‡åŒ–ç›®æ ‡
- **æ€»ä½“æµ‹è¯•è¦†ç›–ç‡**: ä»10%æå‡è‡³70%
- **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ°85%
- **é›†æˆæµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ°90%
- **APIæµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ°100%
- **å¼‚å¸¸æµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ°80%

### è´¨é‡ç›®æ ‡
- **ä»£ç è´¨é‡**: é€šè¿‡æ‰€æœ‰é™æ€åˆ†æ
- **åŠŸèƒ½æ­£ç¡®æ€§**: æ‰€æœ‰å…³é”®åŠŸèƒ½è¢«éªŒè¯
- **æ€§èƒ½æŒ‡æ ‡**: æ»¡è¶³æ€§èƒ½è¦æ±‚
- **å®‰å…¨æ€§**: æ— å·²çŸ¥å®‰å…¨æ¼æ´

## æµ‹è¯•æ¶æ„è®¾è®¡

### æµ‹è¯•ç›®å½•ç»“æ„
```
tests/
â”œâ”€â”€ common/                 # é€šç”¨æµ‹è¯•å·¥å…·
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ test_setup.rs       # æµ‹è¯•ç¯å¢ƒè®¾ç½®
â”‚   â”œâ”€â”€ test_data.rs        # æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
â”‚   â””â”€â”€ test_utils.rs       # æµ‹è¯•å·¥å…·å‡½æ•°
â”œâ”€â”€ unit/                   # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ domain_tests.rs     # é¢†åŸŸæ¨¡å‹æµ‹è¯•
â”‚   â”œâ”€â”€ service_tests.rs    # æœåŠ¡å±‚æµ‹è¯•
â”‚   â”œâ”€â”€ repository_tests.rs # ä»“åº“å±‚æµ‹è¯•
â”‚   â””â”€â”€ utils_tests.rs     # å·¥å…·ç±»æµ‹è¯•
â”œâ”€â”€ integration/            # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ api_tests.rs        # APIç«¯ç‚¹æµ‹è¯•
â”‚   â”œâ”€â”€ workflow_tests.rs   # å·¥ä½œæµæµ‹è¯•
â”‚   â””â”€â”€ database_tests.rs   # æ•°æ®åº“æµ‹è¯•
â”œâ”€â”€ performance/            # æ€§èƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ benchmark_tests.rs  # åŸºå‡†æµ‹è¯•
â”‚   â””â”€â”€ load_tests.rs       # è´Ÿè½½æµ‹è¯•
â”œâ”€â”€ security/               # å®‰å…¨æµ‹è¯•
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ auth_tests.rs       # è®¤è¯æµ‹è¯•
â”‚   â”œâ”€â”€ validation_tests.rs # éªŒè¯æµ‹è¯•
â”‚   â””â”€â”€ injection_tests.rs  # æ³¨å…¥æ”»å‡»æµ‹è¯•
â””â”€â”€ e2e/                    # ç«¯åˆ°ç«¯æµ‹è¯•
    â”œâ”€â”€ mod.rs
    â””â”€â”€ scenario_tests.rs   # åœºæ™¯æµ‹è¯•
```

### æµ‹è¯•ä¾èµ–é…ç½®

**æ›´æ–° Cargo.toml**:
```toml
[dev-dependencies]
# åŸæœ‰ä¾èµ–
tokio-test = { workspace = true }
mockall = "0.11"
tower = { workspace = true }

# æ–°å¢æµ‹è¯•ä¾èµ–
axum-test = "0.1"          # HTTPæµ‹è¯•
reqwest = { version = "0.11", features = ["json"] }  # HTTPå®¢æˆ·ç«¯
serde_json = "1.0"         # JSONå¤„ç†
fake = { version = "2.9", features = ["derive"] }    # å‡æ•°æ®ç”Ÿæˆ
rand = "0.8"               # éšæœºæ•°ç”Ÿæˆ
criterion = { version = "0.5", features = ["html_reports"] }  # åŸºå‡†æµ‹è¯•
tokio = { version = "1.0", features = ["full"] }     # å¼‚æ­¥æµ‹è¯•
tracing-test = "0.2"       # æ—¥å¿—æµ‹è¯•
mockito = "1.4"            # HTTPæ¨¡æ‹Ÿ
tempfile = "3.8"           # ä¸´æ—¶æ–‡ä»¶
testcontainers = "0.15"    # å®¹å™¨æµ‹è¯•

# æµ‹è¯•å·¥å…·
assert_cmd = "2.0"         # å‘½ä»¤è¡Œæµ‹è¯•
predicates = "3.0"         # æ–­è¨€åº“
pretty_assertions = "1.4"  # ç¾åŒ–æ–­è¨€
insta = "1.34"             # å¿«ç…§æµ‹è¯•
```

## æµ‹è¯•å®ç°è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µ: æµ‹è¯•åŸºç¡€è®¾æ–½ (1å¤©)

#### 1.1 é€šç”¨æµ‹è¯•å·¥å…·
```rust
// tests/common/mod.rs
pub mod test_setup;
pub mod test_data;
pub mod test_utils;

pub use test_setup::*;
pub use test_data::*;
pub use test_utils::*;
```

```rust
// tests/common/test_setup.rs
use std::sync::Arc;
use simple_task_orchestrator::{
    infrastructure::InMemoryTaskRepository,
    services::TaskService,
    config::ConfigManager,
};

pub struct TestEnvironment {
    pub task_service: Arc<TaskService>,
    pub config_manager: ConfigManager,
}

impl TestEnvironment {
    pub fn new() -> Self {
        let task_repository = Arc::new(InMemoryTaskRepository::new());
        let lock_manager = Arc::new(SimpleLockManager::new());
        let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
        let config_manager = ConfigManager::new().unwrap();
        
        Self {
            task_service,
            config_manager,
        }
    }
    
    pub async fn setup_test_tasks(&self, count: usize) -> Vec<Task> {
        let mut tasks = Vec::new();
        
        for i in 0..count {
            let request = CreateTaskRequest {
                work_directory: format!("/test_{}", i),
                prompt: format!("Test prompt {}", i),
                priority: Some(TaskPriority::Medium),
                tags: Some(vec!["test".to_string()]),
            };
            
            let task = self.task_service.create_task(request).await.unwrap();
            tasks.push(task);
        }
        
        tasks
    }
}
```

#### 1.2 æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
```rust
// tests/common/test_data.rs
use fake::{Fake, Faker};
use fake::faker::lorem::en::*;
use fake::faker::internet::en::*;
use simple_task_orchestrator::domain::*;

pub struct TestDataGenerator;

impl TestDataGenerator {
    pub fn create_task_request() -> CreateTaskRequest {
        CreateTaskRequest {
            work_directory: format!("/test/{}", UUIDv4.fake()),
            prompt: Sentence(1..10).fake(),
            priority: Some(TaskPriority::Medium),
            tags: Some(vec![Word().fake()]),
        }
    }
    
    pub fn create_worker_id() -> String {
        Username().fake()
    }
    
    pub fn create_task_id() -> TaskId {
        TaskId::from_uuid(uuid::Uuid::new_v4())
    }
    
    pub fn create_task_result() -> TaskResult {
        TaskResult::success(Sentence(1..5).fake())
    }
}
```

#### 1.3 æµ‹è¯•å·¥å…·å‡½æ•°
```rust
// tests/common/test_utils.rs
use std::time::Duration;
use tokio::time::sleep;

pub async fn wait_for_condition<F, Fut>(condition: F, timeout: Duration) -> Result<(), String>
where
    F: Fn() -> Fut,
    Fut: std::future::Future<Output = bool>,
{
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if condition().await {
            return Ok(());
        }
        sleep(Duration::from_millis(100)).await;
    }
    
    Err("Condition not met within timeout".to_string())
}

pub fn assert_task_equals(expected: &Task, actual: &Task) {
    assert_eq!(expected.id, actual.id);
    assert_eq!(expected.work_directory, actual.work_directory);
    assert_eq!(expected.prompt, actual.prompt);
    assert_eq!(expected.priority, actual.priority);
    assert_eq!(expected.status, actual.status);
}

pub fn create_test_app() -> Router<ApiState> {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    create_routes().with_state(ApiState { task_service })
}
```

### ç¬¬äºŒé˜¶æ®µ: å•å…ƒæµ‹è¯• (2å¤©)

#### 2.1 é¢†åŸŸæ¨¡å‹æµ‹è¯•
```rust
// tests/unit/domain_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::domain::*;
    
    #[test]
    fn test_task_id_creation() {
        let task_id = TaskId::new();
        assert!(!task_id.to_string().is_empty());
    }
    
    #[test]
    fn test_task_id_from_uuid() {
        let uuid = uuid::Uuid::new_v4();
        let task_id = TaskId::from_uuid(uuid);
        assert_eq!(task_id.as_uuid(), &uuid);
    }
    
    #[test]
    fn test_worker_id_validation() {
        // æœ‰æ•ˆID
        assert!(WorkerId::new("valid_worker".to_string()).is_ok());
        
        // ç©ºID
        assert!(WorkerId::new("".to_string()).is_err());
        
        // è¿‡é•¿ID
        let long_id = "a".repeat(101);
        assert!(WorkerId::new(long_id).is_err());
    }
    
    #[test]
    fn test_task_status_transitions() {
        use TaskStatus::*;
        
        // æœ‰æ•ˆè½¬æ¢
        assert!(Waiting.can_transition_to(&Working));
        assert!(Working.can_transition_to(&Completed));
        assert!(Working.can_transition_to(&Failed));
        assert!(Failed.can_transition_to(&Waiting));
        
        // æ— æ•ˆè½¬æ¢
        assert!(!Completed.can_transition_to(&Working));
        assert!(!Working.can_transition_to(&Waiting));
    }
    
    #[test]
    fn test_task_lifecycle() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // åˆå§‹çŠ¶æ€
        assert_eq!(task.status, TaskStatus::Waiting);
        assert!(task.worker_id.is_none());
        assert!(task.started_at.is_none());
        
        // å¼€å§‹ä»»åŠ¡
        let worker_id = WorkerId::new("worker1".to_string()).unwrap();
        task.start(worker_id.clone()).unwrap();
        assert_eq!(task.status, TaskStatus::Working);
        assert_eq!(task.worker_id, Some(worker_id));
        assert!(task.started_at.is_some());
        
        // å®Œæˆä»»åŠ¡
        let result = TaskResult::success("Task completed".to_string());
        task.complete(result).unwrap();
        assert_eq!(task.status, TaskStatus::Completed);
        assert!(task.completed_at.is_some());
    }
    
    #[test]
    fn test_task_retry_logic() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // è®¾ç½®ä¸ºå¤±è´¥çŠ¶æ€
        task.fail("Test failure".to_string()).unwrap();
        assert_eq!(task.status, TaskStatus::Failed);
        assert_eq!(task.retry_count, 0);
        
        // é‡è¯•ä»»åŠ¡
        task.retry().unwrap();
        assert_eq!(task.status, TaskStatus::Waiting);
        assert_eq!(task.retry_count, 1);
        assert!(task.worker_id.is_none());
        
        // æµ‹è¯•é‡è¯•é™åˆ¶
        task.max_retries = 1;
        task.fail("Another failure".to_string()).unwrap();
        assert!(task.retry().is_err());
    }
    
    #[test]
    fn test_task_timeout() {
        let mut task = Task::new(
            "/test".to_string(),
            "Test prompt".to_string(),
            TaskPriority::Medium,
            vec!["test".to_string()],
        );
        
        // æœªå¼€å§‹çš„ä»»åŠ¡ä¸åº”è¶…æ—¶
        assert!(!task.is_expired(3600));
        
        // å¼€å§‹ä»»åŠ¡
        let worker_id = WorkerId::new("worker1".to_string()).unwrap();
        task.start(worker_id).unwrap();
        
        // åˆšå¼€å§‹çš„ä»»åŠ¡ä¸åº”è¶…æ—¶
        assert!(!task.is_expired(3600));
        
        // æ¨¡æ‹Ÿæ—¶é—´è¿‡æœŸ
        task.started_at = Some(task.started_at.unwrap() - chrono::Duration::seconds(3700));
        assert!(task.is_expired(3600));
    }
}
```

#### 2.2 æœåŠ¡å±‚æµ‹è¯•
```rust
// tests/unit/service_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::services::*;
    use simple_task_orchestrator::domain::*;
    
    #[tokio::test]
    async fn test_create_task_success() {
        let env = TestEnvironment::new();
        let request = TestDataGenerator::create_task_request();
        
        let result = env.task_service.create_task(request).await;
        assert!(result.is_ok());
        
        let task = result.unwrap();
        assert!(!task.id.to_string().is_empty());
        assert_eq!(task.status, TaskStatus::Waiting);
        assert_eq!(task.retry_count, 0);
    }
    
    #[tokio::test]
    async fn test_create_task_validation() {
        let env = TestEnvironment::new();
        
        // æµ‹è¯•æ— æ•ˆè·¯å¾„
        let invalid_request = CreateTaskRequest {
            work_directory: "invalid_path".to_string(),
            prompt: "Test prompt".to_string(),
            priority: Some(TaskPriority::Medium),
            tags: None,
        };
        
        let result = env.task_service.create_task(invalid_request).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("absolute path"));
    }
    
    #[tokio::test]
    async fn test_acquire_task() {
        let env = TestEnvironment::new();
        
        // åˆ›å»ºæµ‹è¯•ä»»åŠ¡
        let create_request = TestDataGenerator::create_task_request();
        let task = env.task_service.create_task(create_request).await.unwrap();
        
        // è·å–ä»»åŠ¡
        let acquire_request = AcquireTaskRequest {
            work_path: task.work_directory.clone(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        
        let result = env.task_service.acquire_task(acquire_request).await;
        assert!(result.is_ok());
        
        let acquired_task = result.unwrap().unwrap();
        assert_eq!(acquired_task.id, task.id);
        assert_eq!(acquired_task.status, TaskStatus::Working);
    }
    
    #[tokio::test]
    async fn test_acquire_task_no_available() {
        let env = TestEnvironment::new();
        
        let acquire_request = AcquireTaskRequest {
            work_path: "/nonexistent".to_string(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        
        let result = env.task_service.acquire_task(acquire_request).await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }
    
    #[tokio::test]
    async fn test_complete_task() {
        let env = TestEnvironment::new();
        
        // åˆ›å»ºå¹¶è·å–ä»»åŠ¡
        let create_request = TestDataGenerator::create_task_request();
        let task = env.task_service.create_task(create_request).await.unwrap();
        
        let acquire_request = AcquireTaskRequest {
            work_path: task.work_directory.clone(),
            worker_id: TestDataGenerator::create_worker_id(),
        };
        let acquired_task = env.task_service.acquire_task(acquire_request).await.unwrap().unwrap();
        
        // å®Œæˆä»»åŠ¡
        let complete_request = CompleteTaskRequest {
            original_prompt: None,
            result: Some(TaskDataGenerator::create_task_result()),
        };
        
        let result = env.task_service.complete_task(&acquired_task.id, complete_request).await;
        assert!(result.is_ok());
        
        let completed_task = result.unwrap();
        assert_eq!(completed_task.status, TaskStatus::Completed);
        assert!(completed_task.completed_at.is_some());
    }
    
    #[tokio::test]
    async fn test_task_statistics() {
        let env = TestEnvironment::new();
        
        // åˆ›å»ºæµ‹è¯•ä»»åŠ¡
        env.setup_test_tasks(10).await;
        
        let stats = env.task_service.get_statistics().await.unwrap();
        assert_eq!(stats.total_tasks, 10);
        assert_eq!(stats.completed_tasks, 0);
        assert_eq!(stats.failed_tasks, 0);
        assert_eq!(stats.active_tasks, 10);
        assert_eq!(stats.success_rate, 0.0);
    }
}
```

#### 2.3 ä»“åº“å±‚æµ‹è¯•
```rust
// tests/unit/repository_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::infrastructure::*;
    
    #[tokio::test]
    async fn test_in_memory_repository_create() {
        let repo = InMemoryTaskRepository::new();
        let task = TestDataGenerator::create_task();
        
        let result = repo.create_task(&task).await;
        assert!(result.is_ok());
        
        let task_id = result.unwrap();
        assert_eq!(task_id, task.id);
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_get() {
        let repo = InMemoryTaskRepository::new();
        let task = TestDataGenerator::create_task();
        
        let task_id = repo.create_task(&task).await.unwrap();
        let retrieved_task = repo.get_task(&task_id).await.unwrap();
        
        assert!(retrieved_task.is_some());
        assert_eq!(retrieved_task.unwrap().id, task.id);
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_update() {
        let repo = InMemoryTaskRepository::new();
        let mut task = TestDataGenerator::create_task();
        
        repo.create_task(&task).await.unwrap();
        
        // æ›´æ–°ä»»åŠ¡
        task.prompt = "Updated prompt".to_string();
        repo.update_task(&task).await.unwrap();
        
        let retrieved_task = repo.get_task(&task.id).await.unwrap().unwrap();
        assert_eq!(retrieved_task.prompt, "Updated prompt");
    }
    
    #[tokio::test]
    async fn test_in_memory_repository_list() {
        let repo = InMemoryTaskRepository::new();
        
        // åˆ›å»ºæµ‹è¯•ä»»åŠ¡
        for i in 0..5 {
            let mut task = TestDataGenerator::create_task();
            task.priority = if i % 2 == 0 { TaskPriority::High } else { TaskPriority::Low };
            repo.create_task(&task).await.unwrap();
        }
        
        // æµ‹è¯•è¿‡æ»¤
        let filter = TaskFilter::new().with_priority(TaskPriority::High);
        let (tasks, total) = repo.list_tasks(&filter).await.unwrap();
        
        assert_eq!(total, 3); // 5ä¸ªä»»åŠ¡ä¸­3ä¸ªæ˜¯é«˜ä¼˜å…ˆçº§
        assert_eq!(tasks.len(), 3);
        for task in tasks {
            assert_eq!(task.priority, TaskPriority::High);
        }
    }
}
```

### ç¬¬ä¸‰é˜¶æ®µ: é›†æˆæµ‹è¯• (2å¤©)

#### 3.1 APIç«¯ç‚¹æµ‹è¯•
```rust
// tests/integration/api_tests.rs
mod tests {
    use super::*;
    use axum_test::TestServer;
    use simple_task_orchestrator::handlers::*;
    
    #[tokio::test]
    async fn test_create_task_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt",
                "priority": "medium",
                "tags": ["test"]
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert!(json["data"].is_object());
        assert_eq!(json["data"]["work_directory"], "/test");
    }
    
    #[tokio::test]
    async fn test_create_task_validation_error() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "invalid_path",  // æ— æ•ˆè·¯å¾„
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        assert!(json["error"]["message"].as_str().unwrap().contains("absolute path"));
    }
    
    #[tokio::test]
    async fn test_get_task_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // å…ˆåˆ›å»ºä»»åŠ¡
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // è·å–ä»»åŠ¡
        let response = server.get(&format!("/api/v1/tasks/{}", task_id))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert_eq!(json["data"]["id"], task_id);
    }
    
    #[tokio::test]
    async fn test_get_task_not_found() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.get("/api/v1/tasks/00000000-0000-0000-0000-000000000000")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        assert_eq!(json["error"]["code"], "NOT_FOUND");
    }
    
    #[tokio::test]
    async fn test_list_tasks_api() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // åˆ›å»ºå‡ ä¸ªä»»åŠ¡
        for i in 0..3 {
            server.post("/api/v1/tasks")
                .json(&serde_json::json!({
                    "work_directory": format!("/test_{}", i),
                    "prompt": format!("Test prompt {}", i)
                }))
                .await;
        }
        
        let response = server.get("/api/v1/tasks")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert!(json["data"].as_array().unwrap().len() >= 3);
    }
    
    #[tokio::test]
    async fn test_health_check() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.get("/health")
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(json["success"].as_bool().unwrap());
        assert_eq!(json["data"]["status"], "healthy");
    }
}
```

#### 3.2 å·¥ä½œæµæµ‹è¯•
```rust
// tests/integration/workflow_tests.rs
mod tests {
    use super::*;
    use simple_task_orchestrator::handlers::*;
    
    #[tokio::test]
    async fn test_complete_task_workflow() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 1. åˆ›å»ºä»»åŠ¡
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(create_response.status_code(), 200);
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 2. è·å–ä»»åŠ¡
        let acquire_response = server.get(&format!("/api/v1/tasks/next?work_path=/test&worker_id=worker1"))
            .await;
        
        assert_eq!(acquire_response.status_code(), 200);
        let acquire_json = acquire_response.json();
        assert!(acquire_json["success"].as_bool().unwrap());
        assert!(acquire_json["data"].is_object());
        
        // 3. å®Œæˆä»»åŠ¡
        let complete_response = server.post(&format!("/api/v1/tasks/{}/complete", task_id))
            .json(&serde_json::json!({
                "result": {
                    "status": "success",
                    "output": "Task completed successfully"
                }
            }))
            .await;
        
        assert_eq!(complete_response.status_code(), 200);
        let complete_json = complete_response.json();
        assert!(complete_json["success"].as_bool().unwrap());
        assert_eq!(complete_json["data"]["status"], "completed");
        
        // 4. éªŒè¯ä»»åŠ¡çŠ¶æ€
        let get_response = server.get(&format!("/api/v1/tasks/{}", task_id))
            .await;
        
        assert_eq!(get_response.status_code(), 200);
        let get_json = get_response.json();
        assert_eq!(get_json["data"]["status"], "completed");
    }
    
    #[tokio::test]
    async fn test_task_retry_workflow() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // 1. åˆ›å»ºä»»åŠ¡
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        // 2. è·å–ä»»åŠ¡
        server.get(&format!("/api/v1/tasks/next?work_path=/test&worker_id=worker1"))
            .await;
        
        // 3. æ¨¡æ‹Ÿä»»åŠ¡å¤±è´¥
        let fail_response = server.post(&format!("/api/v1/tasks/{}/complete", task_id))
            .json(&serde_json::json!({
                "result": {
                    "status": "failure",
                    "output": "Task failed"
                }
            }))
            .await;
        
        assert_eq!(fail_response.status_code(), 200);
        
        // 4. é‡è¯•ä»»åŠ¡
        let retry_response = server.post(&format!("/api/v1/tasks/{}/retry", task_id))
            .await;
        
        assert_eq!(retry_response.status_code(), 200);
        let retry_json = retry_response.json();
        assert!(retry_json["success"].as_bool().unwrap());
        assert_eq!(retry_json["data"]["status"], "waiting");
        assert_eq!(retry_json["data"]["retry_count"], 1);
    }
}
```

### ç¬¬å››é˜¶æ®µ: å¹¶å‘å’Œå®‰å…¨æµ‹è¯• (1å¤©)

#### 4.1 å¹¶å‘æµ‹è¯•
```rust
// tests/integration/concurrency_tests.rs
mod tests {
    use super::*;
    use tokio::task::JoinSet;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_concurrent_task_creation() {
        let app = create_test_app();
        let server = Arc::new(TestServer::new(app).unwrap());
        
        let mut join_set = JoinSet::new();
        
        // å¹¶å‘åˆ›å»º100ä¸ªä»»åŠ¡
        for i in 0..100 {
            let server_clone = server.clone();
            join_set.spawn(async move {
                server_clone.post("/api/v1/tasks")
                    .json(&serde_json::json!({
                        "work_directory": format!("/test_{}", i),
                        "prompt": format!("Test prompt {}", i)
                    }))
                    .await
                    .status_code()
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // éªŒè¯æ‰€æœ‰è¯·æ±‚éƒ½æˆåŠŸ
        for status_code in results {
            assert_eq!(status_code, 200);
        }
    }
    
    #[tokio::test]
    async fn test_concurrent_task_acquisition() {
        let app = create_test_app();
        let server = Arc::new(TestServer::new(app).unwrap());
        
        // åˆ›å»ºä¸€ä¸ªä»»åŠ¡
        let create_response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        let task_id = create_response.json()["data"]["id"].as_str().unwrap();
        
        let mut join_set = JoinSet::new();
        
        // å¹¶å‘å°è¯•è·å–åŒä¸€ä¸ªä»»åŠ¡
        for i in 0..10 {
            let server_clone = server.clone();
            join_set.spawn(async move {
                server_clone.get(&format!(
                    "/api/v1/tasks/next?work_path=/test&worker_id=worker_{}",
                    i
                ))
                .await
                .json()
            });
        }
        
        let mut results = Vec::new();
        while let Some(result) = join_set.join_next().await {
            results.push(result.unwrap());
        }
        
        // åªæœ‰ä¸€ä¸ªworkeråº”è¯¥èƒ½è·å–åˆ°ä»»åŠ¡
        let success_count = results.iter()
            .filter(|json| json["success"].as_bool().unwrap() && json["data"].is_object())
            .count();
        assert_eq!(success_count, 1);
    }
}
```

#### 4.2 å®‰å…¨æµ‹è¯•
```rust
// tests/security/auth_tests.rs
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_api_key_required() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "Test prompt"
            }))
            .await;
        
        // å¦‚æœå®ç°äº†APIå¯†é’¥éªŒè¯ï¼Œåº”è¯¥è¿”å›401
        // ç›®å‰å¯èƒ½è¿”å›200ï¼Œéœ€è¦æ ¹æ®å®é™…å®ç°è°ƒæ•´
        assert!(response.status_code() == 200 || response.status_code() == 401);
    }
    
    #[tokio::test]
    async fn test_input_validation() {
        let app = create_test_app();
        let server = TestServer::new(app).unwrap();
        
        // æµ‹è¯•è·¯å¾„éå†æ”»å‡»
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test/../../../etc",
                "prompt": "Test prompt"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
        
        // æµ‹è¯•SQLæ³¨å…¥
        let response = server.post("/api/v1/tasks")
            .json(&serde_json::json!({
                "work_directory": "/test",
                "prompt": "'; DROP TABLE tasks; --"
            }))
            .await;
        
        assert_eq!(response.status_code(), 200);
        let json = response.json();
        assert!(!json["success"].as_bool().unwrap());
    }
}
```

### ç¬¬äº”é˜¶æ®µ: æ€§èƒ½æµ‹è¯• (1å¤©)

#### 5.1 åŸºå‡†æµ‹è¯•
```rust
// tests/performance/benchmark_tests.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use simple_task_orchestrator::services::TaskService;
use simple_task_orchestrator::infrastructure::{InMemoryTaskRepository, SimpleLockManager};
use std::sync::Arc;

fn bench_task_creation(c: &mut Criterion) {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    let mut group = c.benchmark_group("task_creation");
    
    for size in [1, 10, 100].iter() {
        group.bench_with_input(BenchmarkId::new("create_tasks", size), size, |b, &size| {
            b.to_async(tokio::runtime::Runtime::new().unwrap())
                .iter(|| async {
                    for _ in 0..size {
                        let request = TestDataGenerator::create_task_request();
                        task_service.create_task(request).await.unwrap();
                    }
                });
        });
    }
    
    group.finish();
}

fn bench_task_acquisition(c: &mut Criterion) {
    let task_repository = Arc::new(InMemoryTaskRepository::new());
    let lock_manager = Arc::new(SimpleLockManager::new());
    let task_service = Arc::new(TaskService::new(task_repository, lock_manager, 3, 3600));
    
    // é¢„å…ˆåˆ›å»ºä»»åŠ¡
    tokio::runtime::Runtime::new().unwrap().block_on(async {
        for i in 0..100 {
            let request = CreateTaskRequest {
                work_directory: "/test".to_string(),
                prompt: format!("Test prompt {}", i),
                priority: Some(TaskPriority::Medium),
                tags: None,
            };
            task_service.create_task(request).await.unwrap();
        }
    });
    
    c.bench_function("task_acquisition", |b| {
        b.to_async(tokio::runtime::Runtime::new().unwrap())
            .iter(|| async {
                let request = AcquireTaskRequest {
                    work_path: "/test".to_string(),
                    worker_id: "worker1".to_string(),
                };
                task_service.acquire_task(request).await
            });
    });
}

criterion_group!(benches, bench_task_creation, bench_task_acquisition);
criterion_main!(benches);
```

#### 5.2 è´Ÿè½½æµ‹è¯•
```javascript
// tests/load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
    stages: [
        { duration: '30s', target: 10 },  // é¢„çƒ­
        { duration: '1m', target: 50 },   // è´Ÿè½½
        { duration: '30s', target: 0 },   // å†·å´
    ],
    thresholds: {
        http_req_duration: ['p(95)<200'], // 95%çš„è¯·æ±‚åœ¨200mså†…å®Œæˆ
        http_req_failed: ['rate<0.01'],   // å¤±è´¥ç‡å°äº1%
    },
};

const BASE_URL = 'http://localhost:8080';

export default function () {
    // åˆ›å»ºä»»åŠ¡
    let createResponse = http.post(`${BASE_URL}/api/v1/tasks`, JSON.stringify({
        work_directory: `/test/${__VU}`,
        prompt: `Test prompt from VU ${__VU}`,
        priority: 'medium',
        tags: ['load-test'],
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
    
    check(createResponse, {
        'create task status is 200': (r) => r.status === 200,
        'create task success': (r) => JSON.parse(r.body).success === true,
    });
    
    // è·å–ä»»åŠ¡åˆ—è¡¨
    let listResponse = http.get(`${BASE_URL}/api/v1/tasks`);
    
    check(listResponse, {
        'list tasks status is 200': (r) => r.status === 200,
        'list tasks success': (r) => JSON.parse(r.body).success === true,
    });
    
    sleep(1);
}
```

## æµ‹è¯•è¿è¡Œå’ŒæŠ¥å‘Š

### æµ‹è¯•è¿è¡Œè„šæœ¬
```bash
#!/bin/bash
# scripts/run_tests.sh

set -e

echo "ğŸ§ª è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶..."

# 1. å•å…ƒæµ‹è¯•
echo "ğŸ“‹ è¿è¡Œå•å…ƒæµ‹è¯•..."
cargo test --lib -- --test-threads=1

# 2. é›†æˆæµ‹è¯•
echo "ğŸ”— è¿è¡Œé›†æˆæµ‹è¯•..."
cargo test --test "*"

# 3. æ€§èƒ½æµ‹è¯•
echo "âš¡ è¿è¡Œæ€§èƒ½æµ‹è¯•..."
cargo bench

# 4. ä»£ç è¦†ç›–ç‡
echo "ğŸ“Š ç”Ÿæˆä»£ç è¦†ç›–ç‡æŠ¥å‘Š..."
cargo tarpaulin --out Html --output-dir coverage/

# 5. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
echo "ğŸ“„ ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š..."
python scripts/generate_test_report.py

echo "âœ… æµ‹è¯•å®Œæˆï¼"
echo "ğŸ“ˆ æŸ¥çœ‹è¦†ç›–ç‡æŠ¥å‘Š: coverage/index.html"
```

### æµ‹è¯•æŠ¥å‘Šæ¨¡æ¿
```python
# scripts/generate_test_report.py
import json
import datetime
import subprocess

def generate_test_report():
    report = {
        "timestamp": datetime.datetime.now().isoformat(),
        "project": "Simple Task Orchestrator",
        "version": "1.0.0",
        "test_results": {}
    }
    
    # è¿è¡Œæµ‹è¯•å¹¶æ”¶é›†ç»“æœ
    try:
        # å•å…ƒæµ‹è¯•ç»“æœ
        unit_result = subprocess.run(
            ["cargo", "test", "--lib", "--", "--test-threads=1"],
            capture_output=True, text=True
        )
        report["test_results"]["unit_tests"] = {
            "passed": unit_result.returncode == 0,
            "output": unit_result.stdout,
            "errors": unit_result.stderr
        }
        
        # é›†æˆæµ‹è¯•ç»“æœ
        integration_result = subprocess.run(
            ["cargo", "test", "--test", "*"],
            capture_output=True, text=True
        )
        report["test_results"]["integration_tests"] = {
            "passed": integration_result.returncode == 0,
            "output": integration_result.stdout,
            "errors": integration_result.stderr
        }
        
        # æ€§èƒ½æµ‹è¯•ç»“æœ
        benchmark_result = subprocess.run(
            ["cargo", "bench"],
            capture_output=True, text=True
        )
        report["test_results"]["benchmark_tests"] = {
            "passed": benchmark_result.returncode == 0,
            "output": benchmark_result.stdout,
            "errors": benchmark_result.stderr
        }
        
    except Exception as e:
        report["error"] = str(e)
    
    # ä¿å­˜æŠ¥å‘Š
    with open("test_report.json", "w") as f:
        json.dump(report, f, indent=2)
    
    print("æµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ: test_report.json")

if __name__ == "__main__":
    generate_test_report()
```

## æµ‹è¯•è´¨é‡ä¿è¯

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚
- **è¡Œè¦†ç›–ç‡**: â‰¥70%
- **å‡½æ•°è¦†ç›–ç‡**: â‰¥80%
- **åˆ†æ”¯è¦†ç›–ç‡**: â‰¥60%
- **æ€»ä½“è¯„åˆ†**: â‰¥85%

### æµ‹è¯•è´¨é‡æ£€æŸ¥
1. **æµ‹è¯•ç‹¬ç«‹æ€§**: æ¯ä¸ªæµ‹è¯•éƒ½åº”è¯¥ç‹¬ç«‹è¿è¡Œ
2. **æµ‹è¯•å¯é‡å¤æ€§**: æµ‹è¯•ç»“æœåº”è¯¥ç¨³å®šå¯é‡å¤
3. **æµ‹è¯•è¦†ç›–èŒƒå›´**: è¦†ç›–æ‰€æœ‰å…³é”®ä¸šåŠ¡é€»è¾‘
4. **æµ‹è¯•æ€§èƒ½**: æµ‹è¯•æœ¬èº«åº”è¯¥å¿«é€Ÿæ‰§è¡Œ
5. **æµ‹è¯•ç»´æŠ¤æ€§**: æµ‹è¯•ä»£ç åº”è¯¥æ˜“äºç»´æŠ¤

### æŒç»­é›†æˆé…ç½®
```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run tests
      run: |
        cargo fmt --all -- --check
        cargo clippy --all-targets --all-features -- -D warnings
        cargo test --all
        cargo tarpaulin --out Xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./cobertura.xml
```

## æµ‹è¯•å®Œæˆæ ‡å‡†

### åŠŸèƒ½æµ‹è¯•æ ‡å‡†
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰APIç«¯ç‚¹è¢«æµ‹è¯•
- [ ] æ‰€æœ‰å¼‚å¸¸æƒ…å†µè¢«è¦†ç›–
- [ ] æ‰€æœ‰å®‰å…¨æœºåˆ¶è¢«éªŒè¯

### æ€§èƒ½æµ‹è¯•æ ‡å‡†
- [ ] APIå“åº”æ—¶é—´ < 100ms (95%)
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ› â‰¥ 1000 RPS
- [ ] å†…å­˜ä½¿ç”¨ç¨³å®š
- [ ] æ— å†…å­˜æ³„æ¼

### è´¨é‡æ ‡å‡†
- [ ] ä»£ç è¦†ç›–ç‡ â‰¥ 70%
- [ ] é™æ€åˆ†æé€šè¿‡
- [ ] æµ‹è¯•æ–‡æ¡£å®Œæ•´
- [ ] æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ

---

**åˆ¶å®šæ—¥æœŸ**: 2025-08-18  
**é¢„è®¡å®Œæˆæ—¶é—´**: 7å¤©  
**æµ‹è¯•è´Ÿè´£äºº**: å¾…æŒ‡å®š  
**æŠ€æœ¯è´Ÿè´£äºº**: å¾…æŒ‡å®š